package slushi.slushiUtils;

import openfl.events.UncaughtErrorEvent;
import haxe.CallStack;
import haxe.io.Path;
import flixel.system.scaleModes.*;
import flixel.group.FlxGroup;

import lime.system.System;
import utils.DateUtil;

import states.StoryMenuState;
import states.freeplay.FreeplayState;
import states.MainMenuState;

/*
 * Crash Handler in game by Edwhak_KillBot, Niz, and Slushi
 */
class CrashHandler
{
	public static var noReturnToThisState:Bool = false;
	public static var inCrash:Bool = false;
	private static var crashes:Int = 0;
	private static var crashesLimit:Int = 4;

	public static function symbolPrevent(error:Dynamic)
	{
		onUncaughtError(error);
	}

	public static function initCrashHandler()
	{
		initCPPCrashHandler();
		Lib.current.loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, onUncaughtError);
	}

	static function initCPPCrashHandler()
	{
		#if cpp
		untyped __global__.__hxcpp_set_critical_error_handler(onCPPError);
		#end
	}

	private static function onCPPError(message:Dynamic):Void
	{
		var randomsMsg:String = "";
		var errMsg:String = "";
		var mainText:String = 'C++ Error! (how?):\n';

		#if cpp
		throw Std.string(message);
		#if windows
		CppAPI.showMessageBox(mainText + message, "Slushi Engine [C++]: Crash Handler", MSG_ERROR);
		#else
		WindowFuncs.windowAlert(mainText + message, "Slushi Engine [C++]: Crash Handler");
		#end
		#end
	}

	static final quotes:Array<String> = [
		"Ha, a null object reference?", // Slushi
		"What the fuck you did!?", // Edwhak
		"CAGASTE.", // Slushi
		"It was Bolo!", // Glowsoony
		"El pollo ardiente", // Edwhak -- wtf edwhak
		"Apuesto que este error viene de SCE y no SLE, verdad?", // Slushi
		"Null References: The Billion Dollar Mistake" // Trock
	];

	static function onUncaughtError(e:Dynamic):Void
	{
		var randomsMsg:String = "";
		var errMsg:String = "";
		var callstackText:String = "";
		var build = Sys.systemName();
		var path:String;
		var callStack:Array<StackItem> = CallStack.exceptionStack(true);
		var dateNow:String = Date.now().toString();
		var build = System.platformLabel;

		dateNow = dateNow.replace(" ", "_");
		dateNow = dateNow.replace(":", "'");

		path = "./assets/debugLogs/crashes/" + "SLEngineCrash_" + dateNow + ".log";

		for (stackItem in callStack)
		{
			switch (stackItem)
			{
				case FilePos(s, file, line, column):
					callstackText += errMsg + file + " (line " + line + ")\n";
				case CFunction:
					callstackText += "Non-Haxe (C) Function";
				case Module(c):
					callstackText += 'Module ${c}';
				default:
					Sys.println(stackItem);
			}
		}

		inCrash = true;
		crashes++;

		var finalGameplayText:String = "";
		finalGameplayText += "Call Stack:\n" + callstackText;
		var finalTerminalText:String = "";
		finalTerminalText += "Call Stack:\n" + callstackText;

		randomsMsg = quotes[Std.random(quotes.length)];

		finalGameplayText += "\n---------------------"
			+ "\n"
			+ randomsMsg
			+ "\n---------------------"
			+ "\n\nThis build is running in "
			+ build
			+ "\n(SLE v"
			+ SlushiMain.slushiEngineVersion
			+ " -- SCE v"
			+ MainMenuState.SCEVersion
			+ ")"
			+ "\nPlease contact with @slushi_ds in Discord if you think this is a bug."
			+ "\n\n"
			+ "Uncaught Error:\n"
			+ e
			+ "\n\n"
			+ "For more info go to: [assets/debugLogs/crashes]";

		finalTerminalText += "\nUncaught Error:\n" + e;

		if (!FileSystem.exists("./assets/debugLogs/crashes/"))
			FileSystem.createDirectory("./assets/debugLogs/crashes/");

		File.saveContent(path, buildCrashReportForFile(e, callstackText, randomsMsg));

		Debug.logError("\nCRASH:\n\x1b[38;5;1m" + finalTerminalText + "\033[0m\n\n");

		crashHandlerTerminal(finalGameplayText);
		Debug.logInfo("Starting Crash Handler");

		#if SLUSHI_CPP_CODE
		slushi.windows.WindowsFuncs.resetAllCPPFunctions();
		#end
	}

	static function buildCrashReportForFile(errorMessage:String, callStack:String, randomQuote:String):String
	{
		var fullContents:String = '=====================\n';
		fullContents += 'Slushi Engine Crash Report\n';
		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'Generated by: Slushi Engine v${SlushiMain.slushiEngineVersion} - SC Engine v${MainMenuState.SCEVersion + ' (${SlushiMain.sceGitCommit})'}\n';
		fullContents += 'System timestamp: ${DateUtil.generateTimestamp(true)}\n';
		var driverInfo = FlxG?.stage?.context3D?.driverInfo ?? 'N/A';
		fullContents += 'GPU Driver info: ${driverInfo}\n';
		fullContents += 'Platform: ${System.platformLabel}\n';
		@:privateAccess
			fullContents += 'Render method: ${utils.logging.CrashHandler.renderMethod()}\n';

		fullContents += '\n';

		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += randomQuote;

		fullContents += '\n\n';

		fullContents += 'Crash message: ${errorMessage}\n';

		fullContents += '\n';

		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'More info:\n';

		fullContents += 'Add an issue in the Slushi Engine repository if you think it is a bug in the engine\n';

		fullContents += '\n';

		var currentState = FlxG.state != null ? Type.getClassName(Type.getClass(FlxG.state)) : 'No state loaded';
		var currentSubState = FlxG.state.subState != null ? Type.getClassName(Type.getClass(FlxG.state.subState)) : 'No substate loaded';

		fullContents += 'Flixel Current State: ${currentState}\n';
		fullContents += 'Flixel Current SubState: ${currentSubState}\n';

		fullContents += '\n';

		fullContents += 'Call Stack: \n${callStack}\n';

		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += utils.MemoryUtil.buildGCInfo();

		fullContents += '\n\n';

		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'Loaded mods: \n';

		if (backend.SafeNullArray.getModsList().length == 0)
		{
			fullContents += 'No mods loaded.\n';
		}
		else
		{
			for (mods in backend.SafeNullArray.getModsList())
			{
				fullContents += '- ${mods}\n';
			}
		}

		fullContents += '\n';

		fullContents += '=====================\n';

		fullContents += '\n';

		fullContents += 'Slushi Engine build info:\n';

		fullContents += 'Version: ${SlushiMain.slushiEngineVersion}\n';
		fullContents += 'Build number: ${SlushiMain.buildNumber}\n';

		fullContents += 'C++ Code: ' + #if SLUSHI_CPP_CODE 'YES' #else 'NO' #end + '\n';
		fullContents += 'Slushi Lua: ' + #if SLUSHI_LUA 'YES' #else 'NO' #end + '\n';

		return fullContents;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	static var canContinue:Bool = false;
	static var camCrashHandler:FlxCamera;

	@:noStack public static var assetGrp:FlxGroup;

	public static function crashHandlerTerminal(text:String = "")
	{
		Application.current.window.title = "Slushi Engine: Crash Handler Mode";
		if (Main.fpsVar != null)
			Main.fpsVar.visible = false;
		FlxG.mouse.useSystemCursor = false;
		FlxG.mouse.visible = false;
		Application.current.window.resizable = false;

		camCrashHandler = new FlxCamera();
		camCrashHandler.bgColor.alpha = 0;
		FlxG.cameras.add(camCrashHandler, false);

		assetGrp = new FlxGroup();
		FlxG.state.add(assetGrp);

		assetGrp.camera = camCrashHandler;

		var contents:String = text;

		var split:Array<String> = contents.split("\n");

		var bg:FlxSprite = new FlxSprite().makeGraphic(FlxG.width, FlxG.height, FlxColor.BLACK);
		bg.scrollFactor.set();
		assetGrp.add(bg);
		bg.alpha = 0.7;

		var watermark = new FlxText(10, 0, 0, "Slushi Engine Crash Handler [v1.3.5] by Slushi");
		watermark.setFormat(Paths.font("vcr.ttf"), 20, FlxColor.WHITE, LEFT, FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
		watermark.scrollFactor.set();
		watermark.borderSize = 1.25;
		watermark.antialiasing = true;
		assetGrp.add(watermark);

		var text0 = new FlxText(10, watermark.y + 20, 0, "Slushi Engine [" + slushi.SlushiMain.slushiEngineVersion + "]");
		text0.setFormat(Paths.font("vcr.ttf"), 20, FlxColor.WHITE, LEFT, FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
		text0.scrollFactor.set();
		text0.borderSize = 1.25;
		assetGrp.add(text0);
		text0.visible = false;

		var text1 = new FlxText(10, text0.y + 30, 0, "SYSTEM CRASH.\nCrash log:");
		text1.setFormat(Paths.font("vcr.ttf"), 20, FlxColor.WHITE, LEFT, FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
		text1.scrollFactor.set();
		text1.color = FlxColor.RED;
		text1.borderSize = 1.25;
		assetGrp.add(text1);
		text1.visible = false;

		var crashtext = new FlxText(10, text1.y + 37, 0, '');
		crashtext.setFormat(Paths.font("vcr.ttf"), 20, FlxColor.WHITE, LEFT, FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
		crashtext.scrollFactor.set();
		crashtext.borderSize = 1.25;
		crashtext.antialiasing = true;
		crashtext.visible = false;
		for (i in 0...split.length - 0)
		{
			if (i == split.length - 18)
				crashtext.text += split[i];
			else
				crashtext.text += split[i] + "\n";
		}
		assetGrp.add(crashtext);

		var text2 = new FlxText(10, crashtext.height + 70, 0, "");
		text2.setFormat(Paths.font("vcr.ttf"), 20, FlxColor.WHITE, LEFT, FlxTextBorderStyle.OUTLINE, FlxColor.BLACK);
		text2.scrollFactor.set();
		text2.borderSize = 1.25;
		#if windows
		text2.text = "\n\nS\\FNF> REBOOTING SYSTEM...";
		#else
		text2.text = "\n\nS/FNF> REBOOTING SYSTEM...";
		#end
		text2.color = slushi.SlushiMain.slushiColor;
		assetGrp.add(text2);
		text2.visible = false;

		if (crashes > crashesLimit)
			{
				#if windows
				CppAPI.showMessageBox("several crashes were detected while the crash handler was already running, the game will be terminated to end the loop.",
					"Loop in Crash Handler Mode", MSG_ERROR);
				Sys.exit(1);
				#else
				WindowFuncs.windowAlert("several crashes were detected while the crash handler was already running, the game will be terminated to end the loop.",
					"Loop in Crash Handler Mode");
				Sys.exit(1);
				#end
			}

		new FlxTimer().start(2, function(tmr:FlxTimer)
		{
			text0.visible = true;
			FlxG.sound.play(SlushiMain.getSLEPath("Sounds/beep.ogg"));
		});

		new FlxTimer().start(3, function(tmr:FlxTimer)
		{
			text1.visible = true;
			FlxG.sound.play(SlushiMain.getSLEPath("Sounds/beep2.ogg"));
		});

		new FlxTimer().start(5, function(tmr:FlxTimer)
		{
			crashtext.visible = true;
			text2.visible = true;
			new FlxTimer().start(5, function(tmr:FlxTimer)
			{
				Main.fpsVar.visible = ClientPrefs.data.showFPS;
				Application.current.window.resizable = true;
				Application.current.window.title = Application.current.meta.get('name');
				if (Type.getClass(FlxG.state) == PlayState)
				{
					if (!PlayState.isStoryMode)
					{
						MainGame.alredyOpen = false;
						MusicBeatState.switchState(new FreeplayState());
						inCrash = false;
						crashes = 0;
					}
					else
					{
						MainGame.alredyOpen = false;
						MusicBeatState.switchState(new StoryMenuState());
						inCrash = false;
						crashes = 0;
					}
				}
				else
				{
					MainGame.alredyOpen = false;
					FlxG.switchState(Type.createInstance(Type.getClass(MainGame.oldState), []));
					inCrash = false;
					crashes = 0;
				}
			});
		});
	}
}